下面這份是「乾乾淨淨版」的單一 HTML 遊戲檔，頁面上只會看到遊戲畫面與畫在 canvas 裡的 HUD / 結局文字，不會有左側一長串說明文字。
把整段存成 `index.html`，用瀏覽器打開就能玩。

* 移動：WASD
* 射擊：J（普通射擊）
* 特殊技能：K（高傷害、有冷卻）
* 目標：在狐狸追擊下走到右下角找到烏龜

  * 若先打倒狐狸再碰到烏龜 → 好結局
  * 若先碰到烏龜但狐狸還活著 → 開放結局
  * 若被狐狸打到 HP 歸零 → 壞結局

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Rescue the Turtle RPG</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #1b2838;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #game {
      border: 4px solid #ffffff;
      box-shadow: 0 0 20px rgba(0,0,0,0.6);
      background: #2ecc71; /* tropical grass */
    }
  </style>
</head>
<body>
<canvas id="game" width="900" height="540"></canvas>

<script>
// -----------------------------------------------------
// Rescue the Turtle - simple top-down mini RPG
// Controls:
//   Move: W A S D
//   Normal shot: J
//   Special shot: K (strong, cooldown)
//   Press Enter to start / restart on title & ending
// -----------------------------------------------------

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const WIDTH = canvas.width;
const HEIGHT = canvas.height;

// Game state
let state = "title"; // "title" | "playing" | "ending"
let endingMessage = "";
let endingDetail = "";

const keys = {};
window.addEventListener("keydown", function(e) {
  keys[e.key] = true;
  if (e.key === "Enter") {
    if (state === "title" || state === "ending") {
      resetGame();
    }
  }
});
window.addEventListener("keyup", function(e) {
  keys[e.key] = false;
});

// Utility
function clamp(v, min, max) {
  return Math.max(min, Math.min(max, v));
}

function rectsOverlap(a, b) {
  return !(
    a.x + a.w < b.x ||
    a.x > b.x + b.w ||
    a.y + a.h < b.y ||
    a.y > b.y + b.h
  );
}

// Entities
const player = {
  x: 80,
  y: 80,
  w: 28,
  h: 28,
  speed: 180,
  hp: 100,
  maxHp: 100,
  color: "#f5cba7",
  shotCooldown: 0,
  specialCooldown: 0
};

const fox = {
  x: WIDTH - 140,
  y: 120,
  w: 30,
  h: 30,
  speed: 140,
  hp: 90,
  maxHp: 90,
  color: "#e67e22",
  shotCooldown: 0,
  illusionTimer: 0,
  alive: true
};

const turtle = {
  x: WIDTH - 120,
  y: HEIGHT - 120,
  w: 32,
  h: 32,
  color: "#16a085",
  rescued: false
};

let projectiles = [];
let illusions = [];
let traps = [];

// Map: simple obstacles & water
const obstacles = [
  {x: 220, y: 60, w: 80, h: 140},
  {x: 420, y: 40, w: 60, h: 110},
  {x: 340, y: 260, w: 120, h: 70},
  {x: 120, y: 280, w: 70, h: 160},
  {x: 560, y: 260, w: 80, h: 160}
];

const waterAreas = [
  {x: 260, y: 360, w: 200, h: 120},
  {x: 560, y: 60, w: 220, h: 120}
];

// Traps from fox
function spawnTrap() {
  traps.push({
    x: fox.x + fox.w / 2 - 8,
    y: fox.y + fox.h / 2 - 8,
    w: 16,
    h: 16,
    ttl: 8 // seconds
  });
}

// Player shots
function spawnShot(isSpecial) {
  const dir = getAimDirection();
  if (!dir) return;
  const speed = isSpecial ? 420 : 320;
  const damage = isSpecial ? 28 : 10;
  projectiles.push({
    x: player.x + player.w/2,
    y: player.y + player.h/2,
    w: 8,
    h: 8,
    vx: dir.dx * speed,
    vy: dir.dy * speed,
    from: "player",
    damage: damage,
    special: isSpecial,
    ttl: 1.6
  });
}

function getAimDirection() {
  // Aim towards fox, or default to right
  if (!fox.alive) {
    return {dx: 1, dy: 0};
  }
  const dx = fox.x + fox.w/2 - (player.x + player.w/2);
  const dy = fox.y + fox.h/2 - (player.y + player.h/2);
  const len = Math.hypot(dx, dy);
  if (len === 0) return {dx: 1, dy: 0};
  return {dx: dx/len, dy: dy/len};
}

// Fox shots
function spawnFoxShot() {
  if (!fox.alive) return;
  const dx = player.x + player.w/2 - (fox.x + fox.w/2);
  const dy = player.y + player.h/2 - (fox.y + fox.h/2);
  const len = Math.hypot(dx, dy) || 1;
  const speed = 260;
  projectiles.push({
    x: fox.x + fox.w/2,
    y: fox.y + fox.h/2,
    w: 10,
    h: 10,
    vx: (dx/len) * speed,
    vy: (dy/len) * speed,
    from: "fox",
    damage: 12,
    special: false,
    ttl: 2.2
  });
}

// Illusions
function spawnIllusion() {
  if (!fox.alive) return;
  const angle = Math.random() * Math.PI * 2;
  const dist = 60 + Math.random()*40;
  illusions.push({
    x: fox.x + Math.cos(angle)*dist,
    y: fox.y + Math.sin(angle)*dist,
    w: fox.w,
    h: fox.h,
    ttl: 4
  });
}

// Player in water?
function isInWater(entity) {
  for (const w of waterAreas) {
    if (rectsOverlap(entity, w)) return true;
  }
  return false;
}

// Obstacle collision resolution
function moveWithCollision(obj, vx, vy, dt) {
  const oldX = obj.x;
  const oldY = obj.y;
  obj.x += vx * dt;
  obj.y += vy * dt;

  // canvas bounds
  obj.x = clamp(obj.x, 0, WIDTH - obj.w);
  obj.y = clamp(obj.y, 0, HEIGHT - obj.h);

  // obstacles
  for (const o of obstacles) {
    if (rectsOverlap(obj, o)) {
      // simple resolution: revert last move in that axis
      if (vx !== 0) obj.x = oldX;
      if (vy !== 0) obj.y = oldY;
    }
  }
}

// Game reset
function resetGame() {
  state = "playing";
  endingMessage = "";
  endingDetail = "";
  player.x = 80;
  player.y = 80;
  player.hp = player.maxHp;
  player.shotCooldown = 0;
  player.specialCooldown = 0;

  fox.x = WIDTH - 140;
  fox.y = 120;
  fox.hp = fox.maxHp;
  fox.alive = true;
  fox.shotCooldown = 1.5;
  fox.illusionTimer = 3;

  turtle.rescued = false;

  projectiles = [];
  illusions = [];
  traps = [];
}

// Update
let lastTime = 0;
function gameLoop(timestamp) {
  const dt = (timestamp - lastTime) / 1000 || 0;
  lastTime = timestamp;

  update(dt);
  draw();

  requestAnimationFrame(gameLoop);
}

function update(dt) {
  if (state === "title" || state === "ending") return;

  // Player movement
  let speed = player.speed;
  if (isInWater(player)) {
    speed *= 1.25; // faster in water
  }

  let vx = 0, vy = 0;
  if (keys["w"] || keys["W"]) vy -= speed;
  if (keys["s"] || keys["S"]) vy += speed;
  if (keys["a"] || keys["A"]) vx -= speed;
  if (keys["d"] || keys["D"]) vx += speed;

  if (vx !== 0 && vy !== 0) {
    const len = Math.sqrt(2);
    vx /= len;
    vy /= len;
  }

  moveWithCollision(player, vx, vy, dt);

  // Player shooting
  if (player.shotCooldown > 0) player.shotCooldown -= dt;
  if (player.specialCooldown > 0) player.specialCooldown -= dt;

  if (keys["j"] || keys["J"]) {
    if (player.shotCooldown <= 0) {
      spawnShot(false);
      player.shotCooldown = 0.35;
    }
  }
  if (keys["k"] || keys["K"]) {
    if (player.specialCooldown <= 0) {
      spawnShot(true);
      player.specialCooldown = 3.0;
    }
  }

  // Fox AI
  if (fox.alive) {
    let fSpeed = fox.speed;
    if (isInWater(fox)) {
      fSpeed *= 0.4; // slow in water
    }
    const dx = player.x - fox.x;
    const dy = player.y - fox.y;
    const dist = Math.hypot(dx, dy) || 1;

    const desired = dist > 40 ? {dx: dx/dist, dy: dy/dist} : {dx: 0, dy: 0};
    moveWithCollision(fox, desired.dx * fSpeed, desired.dy * fSpeed, dt);

    // Fox shooting
    fox.shotCooldown -= dt;
    if (fox.shotCooldown <= 0) {
      spawnFoxShot();
      fox.shotCooldown = 1.8 + Math.random()*0.7;
    }

    // Illusions & traps
    fox.illusionTimer -= dt;
    if (fox.illusionTimer <= 0) {
      spawnIllusion();
      spawnTrap();
      fox.illusionTimer = 6 + Math.random()*2;
    }
  }

  // Projectiles update
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.ttl -= dt;
    if (p.ttl <= 0 ||
        p.x < -20 || p.x > WIDTH+20 ||
        p.y < -20 || p.y > HEIGHT+20) {
      projectiles.splice(i, 1);
      continue;
    }

    if (p.from === "player" && fox.alive) {
      if (rectsOverlap(p, fox)) {
        fox.hp -= p.damage;
        projectiles.splice(i, 1);
        if (fox.hp <= 0) {
          fox.alive = false;
        }
      }
    } else if (p.from === "fox") {
      if (rectsOverlap(p, player)) {
        player.hp -= p.damage;
        projectiles.splice(i, 1);
        if (player.hp <= 0) {
          triggerBadEnding();
        }
      }
    }
  }

  // Traps update
  for (let i = traps.length - 1; i >= 0; i--) {
    const t = traps[i];
    t.ttl -= dt;
    if (t.ttl <= 0) {
      traps.splice(i, 1);
      continue;
    }
    if (rectsOverlap(player, t)) {
      player.hp -= 6 * dt; // damage over time
      if (player.hp <= 0) {
        triggerBadEnding();
      }
    }
  }

  // Illusions update
  for (let i = illusions.length - 1; i >= 0; i--) {
    const ill = illusions[i];
    ill.ttl -= dt;
    if (ill.ttl <= 0) illusions.splice(i, 1);
  }

  // Check turtle contact
  if (!turtle.rescued && rectsOverlap(player, turtle)) {
    turtle.rescued = true;
    if (!fox.alive) {
      triggerGoodEnding();
    } else {
      triggerOpenEnding();
    }
  }
}

// Ending triggers
function triggerGoodEnding() {
  state = "ending";
  endingMessage = "Good Ending";
  endingDetail = "你成功打敗狐狸並搶救了烏龜，島嶼恢復了和平！";
}

function triggerBadEnding() {
  state = "ending";
  endingMessage = "Bad Ending";
  endingDetail = "水豚君被狐狸擊敗，烏龜的下落仍是謎，島嶼失去了守護者…";
}

function triggerOpenEnding() {
  state = "ending";
  endingMessage = "Open Ending";
  endingDetail = "你救出了烏龜，但狐狸逃走了。危機似乎還沒真正結束…";
}

// Drawing
function drawBackground() {
  // main grass
  ctx.fillStyle = "#2ecc71";
  ctx.fillRect(0, 0, WIDTH, HEIGHT);

  // soft gradient sky at top
  const grad = ctx.createLinearGradient(0, 0, 0, 120);
  grad.addColorStop(0, "#3498db");
  grad.addColorStop(1, "#2ecc71");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, WIDTH, 140);

  // water
  ctx.fillStyle = "#1abc9c";
  for (const w of waterAreas) {
    ctx.fillRect(w.x, w.y, w.w, w.h);
  }

  // obstacles (bush / rock)
  ctx.fillStyle = "#145a32";
  for (const o of obstacles) {
    ctx.fillRect(o.x, o.y, o.w, o.h);
  }
}

function drawHUD() {
  // Player HP bar
  const barWidth = 260;
  const barHeight = 18;
  const margin = 10;

  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(margin - 2, margin - 2, barWidth + 4, barHeight + 4);

  const hpRatio = clamp(player.hp / player.maxHp, 0, 1);
  ctx.fillStyle = "#27ae60";
  ctx.fillRect(margin, margin, barWidth * hpRatio, barHeight);

  ctx.strokeStyle = "#ffffff";
  ctx.strokeRect(margin, margin, barWidth, barHeight);

  ctx.fillStyle = "#ffffff";
  ctx.font = "13px system-ui";
  ctx.fillText("Capybara HP: " + Math.max(0, player.hp | 0), margin + 6, margin + 13);

  // Fox HP
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  const fxX = WIDTH - barWidth - margin - 2;
  ctx.fillRect(fxX, margin - 2, barWidth + 4, barHeight + 4);

  const foxRatio = fox.alive ? clamp(fox.hp / fox.maxHp, 0, 1) : 0;
  ctx.fillStyle = "#c0392b";
  ctx.fillRect(fxX + 2, margin, barWidth * foxRatio, barHeight);

  ctx.strokeStyle = "#ffffff";
  ctx.strokeRect(fxX + 2, margin, barWidth, barHeight);

  ctx.fillStyle = "#ffffff";
  ctx.fillText("Fox HP: " + (fox.alive ? Math.max(0, fox.hp | 0) : "0 (defeated)"),
               fxX + 8, margin + 13);

  // Skill status
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.fillRect(margin, HEIGHT - 40, 310, 30);
  ctx.fillStyle = "#ffffff";
  ctx.font = "13px system-ui";
  ctx.fillText("Move: WASD   J: Shot   K: Special (" +
               (player.specialCooldown <= 0 ? "Ready" : player.specialCooldown.toFixed(1) + "s") + ")",
               margin + 8, HEIGHT - 20);
}

function drawEntities() {
  // Turtle
  ctx.fillStyle = turtle.color;
  ctx.fillRect(turtle.x, turtle.y, turtle.w, turtle.h);
  // Turtle shell lines
  ctx.strokeStyle = "#0b5345";
  ctx.strokeRect(turtle.x, turtle.y, turtle.w, turtle.h);

  // Player (capybara)
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.w, player.h);
  ctx.fillStyle = "#6e2c00";
  ctx.fillRect(player.x + 6, player.y + 6, 6, 6); // simple eye

  // Fox
  if (fox.alive) {
    ctx.fillStyle = fox.color;
    ctx.fillRect(fox.x, fox.y, fox.w, fox.h);
    ctx.fillStyle = "#6e2c00";
    ctx.fillRect(fox.x + fox.w - 10, fox.y + 6, 6, 6);
  }

  // Illusions
  ctx.fillStyle = "rgba(230, 126, 34, 0.35)";
  for (const ill of illusions) {
    ctx.fillRect(ill.x, ill.y, ill.w, ill.h);
  }

  // Traps
  ctx.fillStyle = "#8e44ad";
  for (const t of traps) {
    ctx.fillRect(t.x, t.y, t.w, t.h);
  }

  // Projectiles
  for (const p of projectiles) {
    ctx.fillStyle = p.from === "player"
      ? (p.special ? "#f1c40f" : "#fdfefe")
      : "#e74c3c";
    ctx.fillRect(p.x, p.y, p.w, p.h);
  }
}

function drawTitle() {
  drawBackground();
  drawEntities();

  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(0, 0, WIDTH, HEIGHT);

  ctx.fillStyle = "#ffffff";
  ctx.textAlign = "center";

  ctx.font = "40px system-ui";
  ctx.fillText("Rescue the Turtle", WIDTH / 2, HEIGHT / 2 - 60);

  ctx.font = "20px system-ui";
  ctx.fillText("水豚君的冒險：搶救烏龜", WIDTH / 2, HEIGHT / 2 - 20);

  ctx.font = "16px system-ui";
  ctx.fillText("目標：避開狐狸與陷阱，找到右下角的烏龜並搶救牠。", WIDTH / 2, HEIGHT / 2 + 20);
  ctx.fillText("提示：水豚君在水裡會變快，狐狸在水裡會變慢。", WIDTH / 2, HEIGHT / 2 + 45);

  ctx.font = "18px system-ui";
  ctx.fillText("按 Enter 開始遊戲", WIDTH / 2, HEIGHT / 2 + 90);

  ctx.textAlign = "left";
}

function drawEnding() {
  drawBackground();
  drawEntities();
  drawHUD();

  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(0, 0, WIDTH, HEIGHT);

  ctx.fillStyle = "#ffffff";
  ctx.textAlign = "center";

  ctx.font = "44px system-ui";
  ctx.fillText(endingMessage, WIDTH / 2, HEIGHT / 2 - 40);

  ctx.font = "20px system-ui";
  wrapText(endingDetail, WIDTH / 2, HEIGHT / 2 + 10, 640, 26);

  ctx.font = "20px system-ui";
  ctx.fillText("按 Enter 再玩一次", WIDTH / 2, HEIGHT / 2 + 110);

  ctx.textAlign = "left";
}

function wrapText(text, x, y, maxWidth, lineHeight) {
  const words = text.split("");
  let line = "";
  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n];
    const metrics = ctx.measureText(testLine);
    const testWidth = metrics.width;
    if (testWidth > maxWidth && n > 0) {
      ctx.fillText(line, x, y);
      line = words[n];
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line, x, y);
}

function draw() {
  if (state === "title") {
    drawTitle();
    return;
  }

  drawBackground();
  drawEntities();
  drawHUD();

  if (state === "ending") {
    drawEnding();
  }
}

// Start
resetGame();
state = "title";
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
```
